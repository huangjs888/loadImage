{"version":3,"file":"loadImage.min.js","sources":["../src/index.ts"],"sourcesContent":["/*\n * @Author: Huangjs\n * @Date: 2023-02-13 15:22:58\n * @LastEditors: Huangjs\n * @LastEditTime: 2023-08-17 11:38:49\n * @Description: ******\n */\n\n// 关于HTTP缓存问题：\n// 1，直接使用new Image()，或者img元素，当相同的图片url再次访问，浏览器会直接使用缓存图片（强缓存），不会向后端发送任何请求，即使后端响应头设置了协商缓存字段要求协商缓存，浏览器依然使用的是强缓存，不会出现304。但是除非后端设置响应头Cache-Control为no-store，此时图片会重新请求。\n// 2，这里使用ajax请求图片，会严格按照http缓存机制来，比如后端设置响应头Cache-Control为maxage=xxx，就会使用强缓存，后端响应头设置了协商缓存字段，就会使用协商缓存，会有304验证等。\n// 3，这里面注意XMLHttpRequest在第二次请求协商缓存的时候，除非请求主动设置了协商缓存字段，此时响应才会真正返回304（且不会去读缓存数据），否则都会自动转换成200，并读取缓存数据返回。\n// 4，HTTP缓存时存在disk或memory里的，靠浏览器默认去读取，ajax还会发一次304请求，如果不想这样浪费请求时间，并且确定图片不会变化，其实可以自己做缓存，可以将请求的数据（也可以转base64）存入到IndexDB，下次请求之前先从中取，没有再请求\n/* const lastModified: { [key in string]: string } = {};\nconst etag: { [key in string]: string } = {}; */\nconst proxy = function proxy(url: string, progress?: (e: ProgressEvent) => void) {\n  return new Promise<string>((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.onprogress = (e) => {\n      if (e.lengthComputable) {\n        typeof progress === 'function' && progress(e);\n      }\n    };\n    xhr.onloadend = (e) => {\n      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n        /* let modified = xhr.getResponseHeader('Last-Modified');\n        if (modified) {\n          lastModified[url] = modified;\n        }\n        modified = xhr.getResponseHeader('Etag');\n        if (modified) {\n          etag[url] = modified;\n        } */\n        // URL.createObjectURL对应资源此时是存在内存里，浏览器关闭或主动revoke会释放掉\n        // resolve里面使用完url之后记得及时释放掉，释放内存后，地址就无效了\n        resolve(URL.createObjectURL(xhr.response));\n      } else {\n        reject(e);\n      }\n    };\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    /* if (lastModified[url]) {\n      // 此种模式，http先是有个OPTIONS请求，再有一个304请求\n      xhr.setRequestHeader('If-Modified-Since', lastModified[url]);\n    }\n    if (etag[url]) {\n      // 此种模式，只有304请求\n      xhr.setRequestHeader('If-None-Match', etag[url]);\n    }\n    xhr.setRequestHeader('Cache-Control', 'no-cache'); */\n    xhr.send();\n  });\n};\n\n// 对image.src进行劫持，一劳永逸\nlet isHijack = false;\nexport function hijackImage() {\n  if (isHijack) {\n    return;\n  }\n  // 这里对HTMLImageElement元素的src进行重写，再设置src的时候使用ajax获取图片资源，目的是监听image的onprogress事件生效\n  const { prototype } = HTMLImageElement;\n  const descriptor = Object.getOwnPropertyDescriptor(prototype, 'src');\n  if (descriptor) {\n    isHijack = true;\n    Object.defineProperty(prototype, 'src', {\n      ...descriptor,\n      set: function set(value, ...args) {\n        if (descriptor.set) {\n          const setter = descriptor.set;\n          if (value && value.indexOf('blob:') !== 0) {\n            proxy(value, this.onprogress)\n              .then((url) => {\n                const onload = this.onload;\n                this.onload = function (e: Event) {\n                  // 释放内存\n                  URL.revokeObjectURL(url);\n                  onload && onload.apply(this, [e]);\n                };\n                // 图片资源加载完成后会缓存，缓存数据丢给image原始src操作（这里就会多个数据转存的时间）\n                setter.apply(this, [url, ...args]);\n              })\n              .catch(() => {\n                // 出现跨域等无法加载图片情况，会重新丢给image原始src操作\n                setter.apply(this, [value, ...args]);\n              });\n          } else {\n            // blob图片直接丢给image原始src操作\n            setter.apply(this, [value, ...args]);\n          }\n        }\n      },\n    });\n    return () => {\n      isHijack = false;\n      // 删除劫持\n      Object.defineProperty(prototype, 'src', descriptor);\n    };\n  }\n  return;\n}\n\n// 原始图片加载\nexport const loadImageBase = function loadImageBase(url: string, progress?: (v: number) => void) {\n  return new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image();\n    const off = () => {\n      image.onload = null;\n      image.onprogress = null;\n      image.onerror = null;\n    };\n    image.onload = () => {\n      resolve(image);\n      off();\n    };\n    image.onerror = (e) => {\n      reject(e);\n      off();\n    };\n    if (typeof progress === 'function') {\n      image.onprogress = (e) => progress(e.loaded / e.total);\n    }\n    image.src = url;\n  });\n};\n\nexport default function (url: string, progress?: (v: number) => void) {\n  // 加载图片需要进度条的使用proxy代理加载\n  if (typeof progress === 'function') {\n    return (\n      proxy(url, (e) => progress(e.loaded / e.total))\n        .then((_url) =>\n          // 该loadImageBase成功后会把then里return的image抛给外面调用者的then\n          // 该loadImageBase失败后会先走下面catch的loadImageBase，而不是直接抛到外面调用者的catch\n          loadImageBase(_url).then((image) => {\n            URL.revokeObjectURL(_url);\n            return image;\n          }),\n        )\n        // 该loadImageBase成功后会抛给外面调用者的then\n        // 该loadImageBase失败后会抛到外面调用者的catch\n        .catch(() => loadImageBase(url))\n    );\n  } else {\n    return loadImageBase(url);\n  }\n}\n"],"names":["proxy","url","progress","Promise","resolve","reject","xhr","XMLHttpRequest","onprogress","e","lengthComputable","onloadend","status","URL","createObjectURL","response","open","responseType","send","isHijack","hijackImage","prototype","HTMLImageElement","descriptor","Object","getOwnPropertyDescriptor","defineProperty","_extends","set","value","args","setter","indexOf","this","then","onload","revokeObjectURL","apply","catch","loadImageBase","image","Image","off","onerror","loaded","total","src","index","_url"],"mappings":"oOAeA,MAAMA,EAAQ,SAAeC,EAAaC,GACxC,OAAO,IAAIC,SAAgB,CAACC,EAASC,KACnC,MAAMC,EAAM,IAAIC,eAChBD,EAAIE,WAAcC,IACZA,EAAEC,kBACgB,mBAAbR,GAA2BA,EAASO,EAC7C,EAEFH,EAAIK,UAAaF,IACVH,EAAIM,QAAU,KAAoB,IAAbN,EAAIM,QAAgC,MAAfN,EAAIM,OAWjDR,EAAQS,IAAIC,gBAAgBR,EAAIS,WAEhCV,EAAOI,EACT,EAEFH,EAAIU,KAAK,MAAOf,GAChBK,EAAIW,aAAe,OAUnBX,EAAIY,MAAM,GAEd,EAGA,IAAIC,GAAW,EACR,SAASC,IACd,GAAID,EACF,OAGF,MAAME,UAAEA,GAAcC,iBAChBC,EAAaC,OAAOC,yBAAyBJ,EAAW,OAC9D,OAAIE,GACFJ,GAAW,EACXK,OAAOE,eAAeL,EAAW,MAAKM,EAAA,CAAA,EACjCJ,EAAU,CACbK,IAAK,SAAaC,KAAUC,GAC1B,GAAIP,EAAWK,IAAK,CAClB,MAAMG,EAASR,EAAWK,IACtBC,GAAoC,IAA3BA,EAAMG,QAAQ,SACzBhC,EAAM6B,EAAOI,KAAKzB,YACf0B,MAAMjC,IACL,MAAMkC,EAASF,KAAKE,OACpBF,KAAKE,OAAS,SAAU1B,GAEtBI,IAAIuB,gBAAgBnC,GACpBkC,GAAUA,EAAOE,KAAMJ,KAAOxB,IAGhCsB,EAAOM,KAAMJ,KAAOhC,KAAQ6B,EAAM,IAEnCQ,OAAM,KAELP,EAAOM,KAAMJ,KAAOJ,KAAUC,EAAM,IAIxCC,EAAOM,KAAMJ,KAAOJ,KAAUC,EAElC,CACF,KAEK,KACLX,GAAW,EAEXK,OAAOE,eAAeL,EAAW,MAAOE,EAAW,QAjCvD,CAqCF,CAGO,MAAMgB,EAAgB,SAAuBtC,EAAaC,GAC/D,OAAO,IAAIC,SAA0B,CAACC,EAASC,KAC7C,MAAMmC,EAAQ,IAAIC,MACZC,EAAMA,KACVF,EAAML,OAAS,KACfK,EAAMhC,WAAa,KACnBgC,EAAMG,QAAU,IAAI,EAEtBH,EAAML,OAAS,KACb/B,EAAQoC,GACRE,GAAK,EAEPF,EAAMG,QAAWlC,IACfJ,EAAOI,GACPiC,GAAK,EAEiB,mBAAbxC,IACTsC,EAAMhC,WAAcC,GAAMP,EAASO,EAAEmC,OAASnC,EAAEoC,QAElDL,EAAMM,IAAM7C,CAAG,GAEnB,EAEe,SAAA8C,EAAU9C,EAAaC,GAEpC,MAAwB,mBAAbA,EAEPF,EAAMC,GAAMQ,GAAMP,EAASO,EAAEmC,OAASnC,EAAEoC,SACrCX,MAAMc,GAGLT,EAAcS,GAAMd,MAAMM,IACxB3B,IAAIuB,gBAAgBY,GACbR,OAKVF,OAAM,IAAMC,EAActC,KAGxBsC,EAActC,EAEzB"}